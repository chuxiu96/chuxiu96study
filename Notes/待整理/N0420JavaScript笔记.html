<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Script 笔记</title>
    <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>
    <script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <style>
        * {
            margin: 0;
        }

        h4,
        strong {
            color: tomato;
        }

        em {
            font-style: normal;
            color: cornflowerblue;
        }

        p,
        ul {
            text-indent: 2em;
        }

        table,
        th,
        tr,
        td {
            margin: 0 3em;
            padding: 0.2em 2em;
            border: 2px solid gray;
            background-color: #f5f5f5;
            border-collapse: collapse;
            text-align: center;
        }

        th {
            background-color: #3f3f3f;
            color: #f5f5f5;
        }

        a {
            text-decoration: none;
            color: rgb(215, 47, 162);
        }
    </style>
</head>

<body>
    <h3>初识 Java Script</h3>
    <hr>
    <strong>「JavaScript」</strong>：
    <p>运行在客户端的脚本语言，不需要编译，由js解释器(js引擎)逐行解释执行。Node.js也可以用于服务器端编程。</p>
    <strong>「JavaScript组成」</strong>:
    <ul>
        <li>ECMAScript ( JavaScript语法 )</li>
        <li>DOM ( 文档对象模型 ) </li>
        <li>BOM ( 浏览器对象模型 )</li>
    </ul>
    <strong>「JavaScript的能力」</strong>：
    <ul>
        <li>改变 HTML 内容</li>
        <li>改变 HTML 属性</li>
        <li>改变 HTML 样式 (CSS)</li>
        <li>隐藏 HTML 元素</li>
        <li>显示 HTML 元素</li>
    </ul>
    <strong>「JavaScript的作用」</strong>：
    <ul>
        <li>表单动态校验(密码强度检测)</li>
        <li>网页特效</li>
        <li>服务端开发(Node.js)</li>
        <li>桌面程序(Electron)、App(Cordova)、控制硬件-物联网(Ruff)、游戏开发(cocos2d-js)</li>
    </ul>
    <strong>「JavaScript书写位置」</strong>
    <p>JS有3种书写位置，分别为行内、内嵌和外部。</p>
    <p>通常的做法是把函数放入 &lt;head> 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。</p>
    <ul>
        <li>
            行内式 <br>
            &lt;input type="button" value="点我试试" onclick="alert('Hello World')" />
        </li>
        <li>
            内嵌式 <br>
            &lt;script>
            alert('Hello World~!');
            &lt;/script>
        </li>
        <li>
            外部式 （引用外部js文件） <br>
            &lt;script src = "my.js"></script>
        </li>
    </ul>
    <strong>「注释」</strong>
    <ul>
        <li>
            1、单行注释 <br>
            <pre>// comment</pre>
        </li>
        <li>
            2、多行注释 <br>
            <pre>
            /*
            comment 
            comment 
            */</pre>
        </li>
    </ul>
    <strong>「JavaScript 输入」</strong>
    <ul>
        <li>prompt(info) ~ 浏览器弹出输入框，用户可以输入</li>
    </ul>
    <strong>「JavaScript 输出」</strong>
    JavaScript 没有任何打印或者输出的函数
    <ul>
        <li>使用 window.alert() 写入警告框</li>
        <ul>
            <li>
                <pre>
                &lt;script>
                        window.alert(5+6);
                    &lt;/script>
                </pre>
            </li>
        </ul>
        <li>使用 document.write() 写入 HTML 输出</li>
        <ul>
            <li>
                <pre>
                &lt;script>
                        document.write("这是输出");
                    &lt;/script>
                </pre>
            </li>
        </ul>
        <li>使用 innerHTML 写入 HTML 元素 <br> 如需访问 HTML 元素，JavaScript 可使用 <strong>document.getElementById(id)</strong> 方法。
        </li>
        <ul>
            <li>
                <pre>
                &lt;script>
                        document.getElementById("test1").innerHTML = "这不是段落";
                    &lt;/script>
                </pre>
            </li>
        </ul>
        <li>使用 console.log() 写入浏览器控制台</li>
    </ul>
    <p> tips： </p>
    <p>1、更改 HTML 元素的 innerHTML 属性是在 HTML 中显示数据的常用方法。 </p>
    <p>2、在 HTML 文档完全加载后使用 document.write() 将删除所有已有的 HTML </p>
    <p>3、document.write() 方法仅用于测试。</p>
    <hr>

    <h3>JavaScript 语句和语法</h3>

    <strong>「JavaScript 语句」</strong>:
    <p>在 HTML 中，JavaScript 语句是由 web 浏览器“执行”的“指令”。</p>
    <p>JavaScript 语句由以下构成：</p>
    <p>值、运算符、表达式、关键词和注释。</p>

    <strong>「JavaScript 程序」</strong>:
    <p>计算机程序是由计算机“执行”的一系列“指令”。</p>
    <p>在编程语言中，这些编程指令被称为语句。</p>
    <p>JavaScript 程序就是一系列的编程语句。</p>
    <p>注释：在 HTML 中，JavaScript 程序由 web 浏览器执行。</p>
    <em>分号 ;</em>
    <ul>
        <li>分号分隔 JavaScript 语句。</li>
        <li>请在每条可执行的语句之后添加分号</li>
        <li>如果有分号分隔，允许在同一行写多条语句</li>
    </ul>
    <em>空白字符</em>
    <ul>
        <li>JavaScript 会忽略多个空格。您可以向脚本添加空格，以增强可读性。</li>
        <li>在运算符旁边（ = + - * / ）添加空格是个好习惯</li>
    </ul>
    <em>行长度和折行</em>
    <ul>
        <li>行长度 : 代码行控制在 80 个字符以内</li>
        <li>折行 : 如果 JavaScript 语句太长，对其进行折行的最佳位置是 某个运算符 </li>
        <li>折行 : 可以在文本字符串中使用 反斜杠 \ 对代码行进行换行。</li>
    </ul>

    <strong>「JavaScript 代码块」</strong>:
    <p>JavaScript 语句可以用花括号（{...}）组合在代码块中。</p>
    <p>代码块的作用是定义一同执行的语句。</p>

    <strong>「JavaScript 关键词」</strong>:
    <p>JavaScript 语句常常通过某个关键词来标识需要执行的 JavaScript 动作。</p>
    <P>JavaScript 关键词指的是保留的单词。保留词无法用作变量名</P>
    <p>下面的表格列出了一部分将在教程中学到的关键词 : </p>
    <table>
        <tr>
            <th>关键词</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>break</td>
            <td>终止 switch 或循环。</td>
        </tr>
        <tr>
            <td>continue</td>
            <td>跳出循环并在顶端开始。</td>
        </tr>
        <tr>
            <td>debugger</td>
            <td>停止执行 JavaScript，并调用调试函数（如果可用）。</td>
        </tr>
        <tr>
            <td>do ... while</td>
            <td>执行语句块，并在条件为真时重复代码块。</td>
        </tr>
        <tr>
            <td>for</td>
            <td>标记需被执行的语句块，只要条件为真。</td>
        </tr>
        <tr>
            <td>function</td>
            <td>声明函数。</td>
        </tr>
        <tr>
            <td>var</td>
            <td>声明变量。</td>
        </tr>
        <tr>
            <td>if ... else</td>
            <td>标记需被执行的语句块，根据某个条件。</td>
        </tr>
        <tr>
            <td>switch</td>
            <td>标记需被执行的语句块，根据不同的情况。</td>
        </tr>
        <tr>
            <td>return</td>
            <td>退出函数。</td>
        </tr>
        <tr>
            <td>try ... catch</td>
            <td>对语句块实现错误处理。</td>
        </tr>
    </table> <br>
    <hr width="75%">

    <strong>「JavaScript 语法」</strong>:
    <p>JavaScript 语法是一套规则，它定义了 JavaScript 的语言结构。</p>
    <pre>
    var x, y;	// 如何声明变量
    x = 7; y = 8;	// 如何赋值
    z = x + y;	// 如何计算值
</pre>

    <strong>「JavaScript 值（混合值 + 变量值）」</strong>: <br>
    <em>字面量（literal）</em> 一般 固定值
    <p>书写规则：</p>
    <ul>
        <li> Number - 可以是整数或者是小数，或者是科学计数(e)；写数值有无小数点均可
            <pre>3.14 123e5</pre>
        </li>
        <li> String - 可以使用单引号或双引号
            <pre>"Bill Gates" 'Bill Gates' </pre>
        </li>
        <li> 表达式 - 用于计算
            <pre>5+10 5*10</pre>
        </li>
        <li> Array - 定义一个数组
            <pre>[40, 100, 1, 5 ,25, 10]</pre>
        </li>
        <li> Object - 定义一个对象
            <pre>{firstname:"john", lastname:"Doe", age:50, eyecolor:"blue"}</pre>
        </li>
        <li> Function - 定义一个函数
            <pre>function myfunction(a,b) { returen a*b }</pre>
        </li>
    </ul>
    <em>变量（variable）</em>
    <p>变量用于存储数据值</p>
    <p>JavaScript 使用 var 关键词来声明变量。</p>
    <p> = 号用于为变量赋值。</p>
    <p><em> 变量必须以唯一的名称的标识。这些唯一的名称称为标识符。</em></p> <br>
    <p>
        <em>变量可以通过变量名访问。在指令式语言中，变量通常是可变的。字面量是一个恒定的值</em>
    </p>
    <p><em>变量是一个名称。字面量是一个值。</em></p>
    <h4>声明（创建） JavaScript 变量</h4>
    <p>在 JavaScript 中创建变量被称为“声明”变量。</p>
    <ul>
        <li>声明之后，变量是没有值的。（技术上，它的值是 undefined。）</li>
        <li>您可以在一条语句中声明许多变量，以逗号分隔变量</li>
        <li>如果再次声明某个 JavaScript 变量，将不会丢它的值</li>
        <li>一条语句中声明的多个变量不可以同时赋同一个值
            <pre>
            var x,y,z=1;
            结果：x,y 为 undefined， z 为 1。
        </pre>
        </li>
    </ul>
    <h4>JavaScript 算术</h4>
    <ul>
        <li>与代数类似，您能够通过 JavaScript 变量进行算术运算，使用 = 和 + 之类的运算符</li>
        <li>字符串也可以使用加号，但是字符串将被级联
            <pre>var x = "Bill" + " " + "Gates";</pre>
        </li>
        <li>如果把要给数值放入引号中，其余数值会被视作字符串并被级联。
            <pre>
    var x = 3 + 5 + "8";
        计算结果为：88
    </pre>
        </li>
    </ul>

    <hr>
    <strong>「JavaScript 运算符」</strong>: <br>

    <p>JavaScript语言有多种类型的运算符：</p>
    <h4>JavaScript 算数运算符</h4>
    <table>
        <tr>
            <th>运算符</th>
            <th>实例</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>+</td>
            <td></td>
            <td>加法</td>
        </tr>
        <tr>
            <td>-</td>
            <td></td>
            <td>减法</td>
        </tr>
        <tr>
            <td>*</td>
            <td></td>
            <td>乘法</td>
        </tr>
        <tr>
            <td>**</td>
            <td></td>
            <td>幂</td>
        </tr>
        <tr>
            <td>/</td>
            <td></td>
            <td>除法</td>
        </tr>
        <tr>
            <td>%</td>
            <td></td>
            <td>取余</td>
        </tr>
        <tr>
            <td>++</td>
            <td></td>
            <td>递增</td>
        </tr>
        <tr>
            <td>--</td>
            <td></td>
            <td>递减</td>
        </tr>
    </table>

    <h4>运算符优先级</h4>
    <p>运算符优先级（Operator precedence）描述了在算术表达式中所执行操作的顺序。</p>
    <ul>
        <li>乘法（*）和除法（%）比加法（+）和减法（-）拥有更高的优先级。</li>
        <li>使用括号来改变优先级,括号中的运算符会首先被计算。</li>
        <li>当多个运算拥有相同的优先级时（比如加法和减法），对它们的计算是从左向右的</li>
    </ul>
    <em><a href="https://www.w3school.com.cn/js/js_arithmetic.asp">JavaScript 运算符优先级值</a></em>

    <h4>JavaScript 赋值运算符</h4>
    <table>
        <tr>
            <th>运算符</th>
            <th>实例</th>
            <th>等同于</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>=</td>
            <td>x = y</td>
            <td>x = y</td>
            <td></td>
        </tr>
        <tr>
            <td>+=</td>
            <td>x += y</td>
            <td>x = x + y</td>
            <td>向变量添加一个值</td>
        </tr>
        <tr>
            <td>-=</td>
            <td>x -= y</td>
            <td>x = x - y</td>
            <td></td>
        </tr>
        <tr>
            <td>*=</td>
            <td>x *= y</td>
            <td>x = x * y</td>
            <td></td>
        </tr>
        <tr>
            <td>/=</td>
            <td>x /= y</td>
            <td>x = x / y</td>
            <td></td>
        </tr>
        <tr>
            <td>%=</td>
            <td>x %= y</td>
            <td>x = x % y</td>
            <td></td>
        </tr>
    </table>

    <h4>JavaScript 字符串运算符</h4>
    <table>
        <tr>
            <td>+ 运算符</td>
            <td>也可用于对字符串进行相加（concatenate，级联）</td>
            <td>
                <pre>
txt1 = "Bill";
txt2 = "Gates";
txt3 = txt1 + " " + txt2; 
text3结果：Bill Gates
            </pre>
            </td>
        </tr>
        <tr>
            <td>+= 赋值运算符</td>
            <td>也可用于相加（级联）字符串</td>
            <td>
                <pre>
txt1 = "Hello ";
txt1 += "Kitty!"; 
结果：Hello Kitty!
            </pre>
            </td>
        </tr>
        <tr>
            <td>字符串和数字的相加</td>
            <td>一个数字和一个字符串相加将返回一个字符串</td>
            <td>
                <pre>
x = 7 + 8;  结果：15
y = "7" + 8;    结果：78
z = "Hello" + 7;    结果：Hello7
            </pre>
            </td>
        </tr>
    </table>

    <h4>JavaScript 比较运算符</h4>
    <table>
        <tr>
            <th>运算符</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>==</td>
            <td>等于</td>
        </tr>
        <tr>
            <td>===</td>
            <td>等值等型</td>
        </tr>
        <tr>
            <td>!=</td>
            <td>不相等</td>
        </tr>
        <tr>
            <td>!==</td>
            <td>不等值或不等型</td>
        </tr>
        <tr>
            <td>></td>
            <td> 大于</td>
        </tr>
        <tr>
            <td>
                <</td> <td>小于
            </td>
        </tr>
        <tr>
            <td>>=</td>
            <td>大于或等于</td>
        </tr>
        <tr>
            <td>
                <=</td> <td>小于或等于
            </td>
        </tr>
        <tr>
            <td>?</td>
            <td>三元运算符</td>
        </tr>
    </table>

    <h3>JavaScript 逻辑运算符</h3>
    <table>
        <tr>
            <th>运算符</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>&&</td>
            <td>逻辑与</td>
        </tr>
        <tr>
            <td>||</td>
            <td>逻辑或</td>
        </tr>
        <tr>
            <td>!</td>
            <td>逻辑非</td>
        </tr>
    </table>

    <h3>JavaScript 类型运算符</h3>
    <table>
        <tr>
            <th>运算符</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>typeof</td>
            <td>返回变量的类型。</td>
        </tr>
        <tr>
            <td>instanceof</td>
            <td>返回 true，如果对象是对象类型的实例。</td>
        </tr>
    </table>

    <h3>JavaScript 位运算符</h3>
    <p>位运算符处理 32 位数。</p>
    <p>该运算中的任何数值运算数都会被转换为 32 位的数。结果会被转换回 JavaScript 数。</p>
    <table>
        <tr>
            <th>运算符</th>
            <th>描述</th>
            <th>例子</th>
            <th>等同于</th>
            <th>结果</th>
            <th>十进制</th>
        </tr>
        <tr>
            <td>&</td>
            <td>与</td>
            <td>5 & 1</td>
            <td>0101 & 0001</td>
            <td>0001</td>
            <td>1</td>
        </tr>
        <tr>
            <td>|</td>
            <td>或</td>
            <td>5 | 1</td>
            <td>0101 | 0001</td>
            <td>0101</td>
            <td>5</td>
        </tr>
        <tr>
            <td>~</td>
            <td>非</td>
            <td>~5</td>
            <td>~0101</td>
            <td>1010</td>
            <td>10</td>
        </tr>
        <tr>
            <td>^</td>
            <td>异或</td>
            <td>5 ^ 1</td>
            <td>0101 ^ 0001</td>
            <td>0100</td>
            <td>4</td>
        </tr>
        <tr>
            <td>
                <<</td> <td>零填充左位移
            </td>
            <td>5 << 1</td> <td>0101 << 1</td> <td>1010</td>
            <td>10</td>
        </tr>
        <tr>
            <td>>></td>
            <td>有符号右位移</td>
            <td>5 >> 1</td>
            <td>0101 >> 1</td>
            <td>0010</td>
            <td>2</td>
        </tr>
        <tr>
            <td>>>></td>
            <td>零填充右位移</td>
            <td>5 >>> 1</td>
            <td>0101 >>> 1</td>
            <td>0010</td>
            <td>2</td>
        </tr>
    </table>


    <strong>「JavaScript 表达式」</strong>: <br>
    <p>表达式是值、变量和运算符的组合，计算结果是值。</p>
    <pre>
    6 * 10
    x * 10
    "bill"+""+"gates" ~ 计算结果："bill gates"
    3 + "yuan" ~ 计算结果："3yuan"
</pre>

    <strong>「JavaScript 关键词」</strong>: <br>
    <p>JavaScript 关键词用于标识被执行的动作</p>
    <p>和其他任何编程语言一样，JavaScript 保留了一些关键字为自己所用。</p>
    <p>例 ： var 关键词告知浏览器创建新的变量</p>
    <pre>
        var x = 7 + 8;
        var y = x + 5;
</pre>

    <strong>「JavaScript 标识符」</strong>: <br>
    <p>标识符是名称。</p>
    <p>在 JavaScript 中，标识符用于命名变量（以及关键词、函数和标签）。</p>
    <em>命名规则</em>
    <ul>
        <li>名称可包含字母、数字、下划线和美元符号</li>
        <li>首字符必须是字母、下划线（-）或美元符号（$），！ 数值不可以作为首字符 ！</li>
        <li>JavaScript 标识符对大小写敏感</li>
        <li>JavaScript 中不能使用连字符 - 。它是为减法预留的。</li>
        <li>JavaScript 程序员倾向于使用以小写字母开头的驼峰大小写
            <pre>firstName, lastName, masterCard, interCity</pre>
        </li>
    </ul>
    <br>

    <hr>
    <strong>「JavaScript 数据类型」</strong>: <br>
    分为两类
    <p> <em>值类型（基本类型）：</em> 字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。 </p>
    <p> <em>引用数据类型（对象类型）：</em> 对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。 </p>
    <table>
        <tr>
            <th>简单数据类型</th>
            <th>说明</th>
            <th>默认值</th>
        </tr>
        <tr>
            <td>Number</td>
            <td>数字型,包含整型值和浮点型值</td>
            <td>0</td>
        </tr>
        <tr>
            <td>String</td>
            <td>字符串型</td>
            <td>""</td>
        </tr>
        <tr>
            <td>Boolean</td>
            <td>布尔值型</td>
            <td>false</td>
        </tr>
        <tr>
            <td>Undefined</td>
            <td>var a;声明了变量a但是没有赋值，此时a = undefined</td>
            <td>undefined</td>
        </tr>
        <tr>
            <td>Null</td>
            <td>var a = null;声明了变量a为空值</td>
            <td>null</td>
        </tr>
    </table>
    <strong>JavaScript 拥有动态类型</strong>
    <p>1、这意味着相同的变量可用作不同的类型</p>
    <pre>var x;               // x 为 undefined
            var x = 5;           // 现在 x 为数字
            var x = "John";      // 现在 x 为字符串</pre>
    <p>2、变量的数据类型可以使用 typeof 操作符来查看</p>
    <pre>
        typeof "John"                // 返回 string
        typeof 3.14                  // 返回 number
        typeof false                 // 返回 boolean
        typeof [1,2,3,4]             // 返回 object
        typeof {name:'John', age:34} // 返回 object
    </pre>

    <strong>原始数据和复杂数据</strong>
    <p><em>原始数据</em>： 一种没有额外属性和方法的单一简单数据值</p>
    <p>typeof 运算符可返回以下原始类型之一：</p>
    <ul>
        <li>string</li>
        <li>number</li>
        <li>boolean</li>
        <li>undefined</li>
    </ul>
    <pre>
        typeof "Bill"              // 返回 "string"
        typeof 3.14                // 返回 "number"
        typeof true                // 返回 "boolean"
        typeof false               // 返回 "boolean"
        typeof x                   // 返回 "undefined" (假如 x 没有值)
</pre>

    <p><em>复杂数据</em>： </p>
    <p>typeof 运算符可返回以下两种类型之一：</p>
    <ul>
        <li>function</li>
        <li>object</li>
    </ul>
    <br>
    <ul>
        <li>
            <p><em>typeof 运算符把【 对象、数组或 null 】返回 object</em></p>
        </li>
        <li>
            <p><em>typeof 运算符不会把【 函数】 返回 object</em></p>
        </li>
        <li>
            <p><em>typeof 运算符把【 空的字符串变量 】返回 string</em></p>
        </li>
        <li>
            <p><em>typeof 运算符对【 null 】返回 object</em></p>
        </li>
    </ul>
    <br>

    <em>Undefined 与 Null 的区别</em>
    <p>Undefined 与 null 的值相等，但类型不相等</p>
    <pre>
typeof undefined              // undefined
typeof null                   // object
null === undefined            // false
null == undefined             // true
</pre>
    <br>
    <hr width="75%">
    <strong>数据类型 转换</strong>
    <p>JavaScript 变量能够被转换为新变量以及另一种数据类型:</p>
    <ul>
        <li>通过使用 JavaScript 函数</li>
        <li>通过 JavaScript 本身自动转换</li>
    </ul>
    <em>转化为字符串</em>
    <table>
        <tr>
            <th>方式</th>
            <th>说明</th>
            <th>实例</th>
        </tr>
        <tr>
            <td>toString()</td>
            <td>转成字符串</td>
            <td>
                <pre>
x.toString()
(123).toString()
(100 + 23).toString()
        </pre>
            </td>
        </tr>
        <tr>
            <td>String()</td>
            <td>强制转换</td>
            <td>
                <pre>
String(x)         // 从数值变量 x 返回字符串
String(123)       // 从数值文本 123 返回字符串
String(100 + 23)  // 从表达式中的数值返回字符串
        </pre>
            </td>
        </tr>
        <tr>
            <td><em>加号拼接字符串</em></td>
            <td>和字符串拼接的结果都是字符串</td>
            <td>
                <pre>
            var num=1;
            alert(num+'我是字符串')
        </pre>
            </td>
        </tr>
    </table>

    <em>转换为数字型</em>
    <table>
        <tr>
            <th>方式</th>
            <th>说明</th>
            <th>实例</th>
        </tr>
        <tr>
            <td>parseInt(String)函数</td>
            <td>将string类型转成整数型</td>
            <td>
                <pre>
        parseInt('11')
        </pre>
            </td>
        </tr>
        <tr>
            <td>parseFloat(String)函数</td>
            <td>将string类型转成浮点型</td>
            <td>parseFloat('11.2')</td>
        </tr>
        <tr>
            <td>Number() 强制转换函数</td>
            <td>将string类型强制转换为数值型 </td>
            <td>Number('12')</td>
        </tr>
        <tr>
            <td>js隐式转换 ( - * /)</td>
            <td>利用算数运算隐式转换为数值型</td>
            <td>'12' - 0</td>
        </tr>
    </table>

    <em>转换为布尔型</em>
    <p>代表空、否定的值会被转换为false，如''、0、NaN、null、undefined 其余值都会被转换为true</p>
    <table>
        <tr>
            <th>方式</th>
            <th>说明</th>
            <th>实例</th>
        </tr>
        <tr>
            <td>Boolean()</td>
            <td>其他类型转换为布尔值</td>
            <td>Boolean('true')</td>
        </tr>
    </table>

    <br>
    <hr width="75%">
    <strong>JavaScript 数字</strong>
    <table>
        <tr>
            <th>类型</th>
            <th>说明</th>
            <th>实例</th>
        </tr>
        <tr>
            <td>JavaScript 数字</td>
            <td>
                <ul>
                    <li>书写数字时带不带小数点均可。</li>
                    <li>超大或超小的数可通过科学计数法来写</li>
                    <li>JavaScript 数字始终是 64 位的浮点数, 0 到 51 存储数字（片段），52 到 62 存储指数，63 位存储符号</li>
                    <li>精度 ： <br> 整数（不使用指数或科学计数法）会被精确到 15 位；<br> 小数的最大数是 17 位，但是浮点的算数并不总是 100% 精准（可使用使用乘除法解决）</li>
                    <li>JavaScript 字符串可以拥有数字内容，所有数字运算中，JavaScript 会尝试将字符串转换为数字（+还是级联）</li>
                </ul>
            </td>
            <td>
                <pre>
var x = 3.14;    // 带小数点的数值
var y = 3;       // 不带小数点的数值
————————————————————————————————————————
var x = 123e5;    // 12300000
var y = 123e-5;   // 0.00123
————————————————————————————————————————
var x = 999999999999999;   // x 将是 999999999999999
var y = 9999999999999999;  // y 将是 10000000000000000
————————————————————————————————————————
var x = 0.2 + 0.1;         // x 将是 0.30000000000000004
var x = (0.2 * 10 + 0.1 * 10) / 10;       // x 将是 0.3
————————————————————————————————————————
var x = "100";
var y = "10";
        var z = x * y;       // z 将是 1000
            </pre>
            </td>
        </tr>
    </table>
    <em>字符串</em>
    <table>
        <tr>
            <td>数字+字符串</td>
            <td>字符串级联</td>
            <td>
                <pre>
var x = 10;
var y = 20;
var z = "30";
var result = x + y + z;  // 3030
            </pre>
            </td>
        </tr>
        <tr>
            <td>数字字符串</td>
            <td>- / * ： 进行算数运算 <br>
                + ： 字符串级联</td>
            <td>
                <pre>
var x = "100";
var y = "10";
var z = x / y;       // z 将是 10
————————————————————————————————————————
var x = "100";
var y = "10";
var z = x + y;       // z 不会是 110（而是 10010）
            </pre>
            </td>
        </tr>
    </table>

    <em>NaN - 非数值</em>
    <p>NaN 属于 JavaScript 保留词，指示某个数不是合法数。</p>
    <ul>
        <li>尝试用一个非数字字符串进行除法会得到 NaN（Not a Number）
            <pre>var x = 100 / "Apple";  // x 将是 NaN（Not a Number）</pre>
        </li>
        <li>假如字符串包含数值，则结果将是数
            <pre>var x = 100 / "10";     // x 将是 10</pre>
        </li>
        <li>您可使用全局 JavaScript 函数 isNaN() 来确定某个值是否是数
            <pre>var x = 100 / "Apple";
            isNaN(x);               // 返回 true，因为 x 不是数</pre>
        </li>
        <li>NaN 是数，typeof NaN 返回 number
            <pre>typeof NaN;             // 返回 "number"</pre>
        </li>
    </ul>
    <em>Infinity</em>
    <p>Infinity （或 -Infinity）是 JavaScript 在计算数时超出最大可能数范围时返回的值。</p>
    <ul>
        <li>除以 0（零）也会生成 Infinity
            <pre>var x =  2 / 0;          // x 将是 Infinity
        var y = -2 / 0;          // y 将是 -Infinity</pre>
        </li>
        <li>Infinity 是数：typeOf Infinity 返回 number。
            <pre>typeof Infinity;        // 返回 "number"</pre>
        </li>
    </ul>

    <em>进制</em>
    <ul>
        <li>在JS中八进制前面加0，十六进制前面加 0x
            <pre>var num1 = 07;   // 对应十进制的7</pre>
        </li>
        <li>十六进制数字序列范围：0~9以及A~F
            <pre>var x = 0xFF;             // x 将是 255。</li>
    <li>能够使用 toString() 方法把数输出为十六进制、八进制或二进制 <pre>var myNumber = 128;
        myNumber.toString(16);     // 返回 80
        myNumber.toString(8);      // 返回 200
        myNumber.toString(2);      // 返回 10000000</pre>
        </li>
    </ul>

    <em>数值可以是对象</em>
    <ul>
        <li>可以通过关键词 new 定义为对象：var y = new Number(123)
            <pre>
        var x = 123;
        var y = new Number(123);
        
        // typeof x 返回 number
        // typeof y 返回 object</pre>
        </li>
        <li>请不要创建数值对象。这样会拖慢执行速度。<br> new 关键词使代码复杂化，并产生某些无法预料的结果：
            <ul>
                <li>当使用 == 相等运算符时，相等的数看上去相等
                    <pre>
var x = 500;             
var y = new Number(500);
// (x == y) 为 true，因为 x 和 y 有相等的值
            </pre>
                </li>
                <li>当使用 === 相等运算符后，相等的数变为不相等，因为 === 运算符需要类型和值同时相等
                    <pre>
var x = 500;             
var y = new Number(500);
// (x === y) 为 false，因为 x 和 y 的类型不同
            </pre>
                </li>
                <li>甚至更糟。对象无法进行对比
                    <pre>
var x = new Number(500);             
var y = new Number(500);
// (x == y) 为 false，因为对象无法比较
            </pre>
                </li>
            </ul>
        </li>
    </ul>
    <strong>JavaScript 数字方法</strong> <br>
    <p>Number 方法帮助您处理数值。</p>
    <p>原始值（比如 3.14 或 2016），无法拥有属性和方法（因为它们不是对象）。
        但是通过 JavaScript，方法和属性也可用于原始值，因为 JavaScript 在执行方法和属性时将原始值视作对象。</p>
    <p>所有数字方法可用于任意类型的数字（字面量、变量或表达式）</p>
    <table>
        <tr>
            <th>number 方法</th>
            <th>说明</th>
            <th>实例</th>
        </tr>
        <tr>
            <td>toString()</td>
            <td>toString() 以字符串返回数值。</td>
            <td>
                <pre>
var x = 123;
x.toString();            // 从变量 x 返回 123
(123).toString();        // 从文本 123 返回 123
(100 + 23).toString();   // 从表达式 100 + 23 返回 123
        </pre>
            </td>
        </tr>
        <tr>
            <td>toExponential()</td>
            <td>toExponential() 返回字符串值，它包含已被四舍五入并使用指数计数法的数字。 <br>
                参数定义小数点后的字符数</td>
            <td>
                <pre>
var x = 9.656;
x.toExponential(2);     // 返回 9.66e+0
x.toExponential(4);     // 返回 9.6560e+0
x.toExponential(6);     // 返回 9.656000e+0
        </pre>
            </td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td>
                <pre>

        </pre>
            </td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td>
                <pre>

        </pre>
            </td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td>
                <pre>

        </pre>
            </td>
        </tr>
    </table>

    <br>
    <hr width="75%">
    <strong>JavaScript 字符串</strong>
    <p>JavaScript 字符串用于存储和操作文本。</p>
    <P>JavaScript 字符串是引号中的零个或多个字符。</P>
    <P>能够使用单引号或双引号,可以在字符串中使用引号，只要不匹配围绕字符串的引号即可</P>
    <pre>
var carname = "Porsche 911";
var carname = 'Porsche 911';
————————————————————————————————————————
var answer = "It's good to see you again!";
var answer = "He is called 'Bill'";
var answer = 'He is called "Bill"';
</pre>
    <em>字符串长度</em>
    <p>内建属性 length 可返回字符串的长度</p>
    <p>
        <pre>
        var txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        var sln = txt.length;
        </pre>
    </p>
    <em>字符串拼接</em>
    <p>字符串 + 任何类型 = 拼接之后的新字符串</p>
    <em>转义字符</em>
    <table>
        <tr>
            <th>代码</th>
            <th>结果</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>\'</td>
            <td>'</td>
            <td>单引号</td>
        </tr>
        <tr>
            <td>\"</td>
            <td>"</td>
            <td>双引号</td>
        </tr>
        <tr>
            <td>\\</td>
            <td>\</td>
            <td>反斜杠</td>
        </tr>
        <tr>
            <td>\</td>
            <td></td>
            <td>退格键</td>
        </tr>
        <tr>
            <td>\f</td>
            <td></td>
            <td>换页</td>
        </tr>
        <tr>
            <td>\</td>
            <td></td>
            <td>新行</td>
        </tr>
        <tr>
            <td>\r</td>
            <td></td>
            <td>回车</td>
        </tr>
        <tr>
            <td>\t</td>
            <td></td>
            <td>水平制表符（tab）</td>
        </tr>
        <tr>
            <td>\v</td>
            <td></td>
            <td>垂直制表符</td>
        </tr>
    </table>
    <em>字符串可以是对象</em>
    <ul>
        <li>可通过关键词 new 定义为对象
            <pre>
var x = "Bill";
    var y = new String("Bill");

    // typeof x 将返回 string
    // typeof y 将返回 object
    </pre>
        </li>
        <li>请不要把字符串创建为对象。它会拖慢执行速度。 <br>new 关键字使代码复杂化。也可能产生一些意想不到的结果
            <ul>
                <li>当使用 == 相等运算符时，相等字符串是相等的
                    <pre>
var x = "Bill";             
    var y = new String("Bill");
    // (x == y) 为 true，因为 x 和 y 的值相等
                </pre>
                </li>
                <li>当使用 === 运算符时，相等字符串是不相等的，因为 === 运算符需要类型和值同时相等。
                    <pre>
var x = "Bill";             
    var y = new String("Bill");
    // (x === y) 为 false，因为 x 和 y 的类型不同（字符串与对象）
                </pre>
                </li>
                <li>甚至更糟。对象无法比较
                    <pre>
var x = new String("Bill");             
    var y = new String("Bill");
    class="code_comment">// (x == y) 为 false，因为 x 和 y 是不同的对象
                </pre>
                </li>
            </ul>
        </li>
    </ul>

    <strong>JavaScript 字符串方法</strong>
    <p>字符串方法帮助您处理字符串</p>
    <p>原始值，比如“Bill Gates”，无法拥有属性和方法（因为它们不是对象）。</p>
    <p>但是通过 JavaScript，方法和属性也可用于原始值，因为在执行方法和属性时 JavaScript 将原始值视为对象。</p>

    <br>
    <hr width="75%">
    <strong>JavaScript 布尔值</strong>
    <ul>
        <li>布尔值只有两个值：true 或 false。</li>
        <li>布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</li>
    </ul>

    <br>
    <hr width="75%">
    <strong>JavaScript 数组</strong>
    <p>JavaScript 数组用于在单一变量中存储多个值</p>
    <p>数组可以用一个单一的名称存放很多值，并且还可以通过引用索引号来访问这些值</p>
    <em>创建数组</em>
    <p>【 使用数组文本是创建 JavaScript 数组最简单的方法。】</p>
    语法：
    <p>
        <pre>var array-name = [item1, item2, ...];</pre>
        <pre>var cars = ["Saab", "Volvo", "BMW"];</pre>
    </p>
    <em>访问数组</em>
    <p>【 通过引用索引号（下标号）来引用某个数组元素 】</p>
    <pre>
        var cars = ["Saab", "Volvo", "BMW"];
        document.getElementById("demo").innerHTML = cars[0]; 
    </pre>
    <p>[0] 是数组中的第一个元素。[1] 是第二个。数组索引从 0 开始。</p>
    <em>改变数组元素</em>
    <p>这条语句修改了 cars 中第一个元素的值</p>
    <pre>       cars[0] = "Opel";</pre>
    <em>访问完整数组</em>
    <p>通过 JavaScript，可通过引用数组名来访问完整数组</p>
    <pre>   var cars = ["Saab", "Volvo", "BMW"];
    document.getElementById("demo").innerHTML = cars; </pre>


    <br><br>
    <hr>
    <h3>let 和 const</h3>
    <p>ES2015 引入了两个重要的 JavaScript 新关键词：let 和 const。
        这两个关键字在 JavaScript 中提供了块作用域（Block Scope）变量（和常量）。</p>
    <p>在 ES2015 之前，JavaScript 只有两种类型的作用域：全局作用域和函数作用域。</p>
    <strong>let 关键字</strong>
    <table>
        <tr>
            <th>类型</th>
            <th>说明</th>
            <th>特点</th>
            <th>实例</th>
        </tr>
        <tr>
            <td>全局作用域</td>
            <td>全局（在函数之外）声明的变量拥有全局作用域。</td>
            <td>全局变量可以在 JavaScript 程序中的任何位置访问。</td>
            <td>
                <pre>
var carName = "porsche";

// 此处的代码可以使用 carName

function myFunction() {
// 此处的代码也可以使用 carName
}
            </pre>
            </td>
        </tr>
        <tr>
            <td>函数作用域</td>
            <td>局部（函数内）声明的变量拥有函数作用域。</td>
            <td>局部变量只能在它们被声明的函数内访问。</td>
            <td>
                <pre>
// 此处的代码不可以使用 carName

function myFunction() {
    var carName = "porsche";
    // code here CAN use carName
}

// 此处的代码不可以使用 carName
            </pre>
            </td>
        </tr>
        <tr>
            <td>块作用域</td>
            <td></td>
            <td>
                <ul>
                    <li>通过 var 关键词声明的变量没有块作用域。在块 {} 内声明的变量可以从块之外进行访问</li>
                    <li>使用 let 关键词声明拥有块作用域的变量。在块 {} 内声明的变量无法从块外访问</li>
                </ul>
            </td>
            <td>
                <pre>
{ 
    var x = 10; 
    }
    // 此处可以使用 x
--------------------------
{ 
    let x = 10;
    }
    // 此处不可以使用 x
            </pre>
            </td>
        </tr>
    </table>
    <strong>var 和 let</strong>
    <table>
        <tr>
            <td>重新声明变量</td>
            <td></td>
            <td>
                <ul>
                    <li>用 var 关键字重新声明变量,也将重新声明块外的变量</li>
                    <li>用 let 关键字重新声明变量,不会重新声明块外的变量</li>
                </ul>
            </td>
            <td>
                <pre>
var x = 10;
// 此处 x 为 10
{ 
    var x = 6;
    // 此处 x 为 6
}
// 此处 x 为 6
--------------------------
var x = 10;
// 此处 x 为 10
{ 
  let x = 6;
  // 此处 x 为 6
}
// 此处 x 为 10
        </pre>
            </td>
        </tr>
        <tr>
            <td>循环作用域</td>
            <td></td>
            <td>
                <ul>
                    <li>循环中使用的变量使用 var 重新声明了循环之外的变量。</li>
                    <li>循环中使用的变量使用 let 不会重新声明循环外的变量。</li>
                </ul>
            </td>
            <td>
                <pre>
var i = 7;
for (var i = 0; i < 10; i++) {
  // 一些语句
}
// 此处，i 为 10
----------------------
let i = 7;
for (let i = 0; i < 10; i++) {
  // 一些语句
}
// 此处 i 为 7
        </pre>
            </td>
        </tr>
        <tr>
            <td>函数作用域</td>
            <td>在函数内声明变量时，使用 var 和 let 很相似。</td>
            <td>都有函数作用域</td>
            <td>
                <pre>
function myFunction() {
    var carName = "porsche";   // 函数作用域
    }
    function myFunction() {
    let carName = "porsche";   // 函数作用域
    }
        </pre>
            </td>
        </tr>
        <tr>
            <td>全局作用域</td>
            <td>如果在块外声明，那么 var 和 let 也很相似。</td>
            <td>都拥有全局作用域</td>
            <td>
                <pre>
var x = 10;       // 全局作用域
let y = 6;       // 全局作用域
        </pre>
            </td>
        </tr>
    </table>
    <h3>HTML 中的全局变量</h3>
    <p>使用 JavaScript 的情况下，全局作用域是 JavaScript 环境。</p>
    <p>在 HTML 中，全局作用域是 window 对象。</p>
    <table>
        <tr>
            <th>类型</th>
            <th>是否属于 window 对象</th>
            <th>实例</th>
        </tr>
        <tr>
            <td>通过 var 关键词定义的全局变量</td>
            <td>属于 window 对象</td>
            <td>
                <pre>
var carName = "porsche";
// 此处的代码可使用 window.carName
        </pre>
            </td>
        </tr>
        <tr>
            <td>通过 let 关键词定义的全局变量</td>
            <td>不属于 window 对象</td>
            <td>
                <pre>
let carName = "porsche";
// 此处的代码不可使用 window.carName
        </pre>
            </td>
        </tr>
    </table>
    <h3>重新声明</h3>
    <table>
        <tr>
            <th>位置</th>
            <th>类型</th>
            <th>是否允许重新声明变量</th>
            <th>实例</th>
        </tr>
        <tr>
            <td>任何位置</td>
            <td>使用 var 重新声明 JavaScript变量</td>
            <td>允许</td>
            <td>
                <pre>
var x = 10;

// 现在，x 为 10
 
var x = 6;

// 现在，x 为 6
        </pre>
            </td>
        </tr>
        <tr>
            <td rowspan="3">在相同的作用域，或在相同的块中</td>
            <td>使用 let 重新声明一个 var 变量</td>
            <td>不允许</td>
            <td>
                <pre>
var x = 10;       // 允许
let x = 6;       // 不允许

{
  var x = 10;   // 允许
  let x = 6;   // 不允许
}
        </pre>
            </td>
        </tr>
        <tr>
            <td>使用 let 重新声明一个 let 变量</td>
            <td>不允许</td>
            <td>
                <pre>
let x = 10;       // 允许
let x = 6;       // 不允许

{
  let x = 10;   // 允许
  let x = 6;   // 不允许
}
        </pre>
            </td>
        </tr>
        <tr>
            <td>使用 var 重新声明一个 let 变量</td>
            <td>不允许</td>
            <td>
                <pre>
let x = 10;       // 允许
var x = 6;       // 不允许

{
  let x = 10;   // 允许
  var x = 6;   // 不允许
}
        </pre>
            </td>
        </tr>
        <tr>
            <td>在不同的作用域或块中</td>
            <td>通过 let 重新声明变量</td>
            <td>允许</td>
            <td>
                <pre>
let x = 6;       // 允许

{
  let x = 7;   // 允许
}

{
  let x = 8;   // 允许
}
        </pre>
            </td>
        </tr>
    </table>
    <em>总结：</em>
    <p>任何位置，允许通过 var 重新声明 js变量</p>
    <p>不同作用域或块中，允许通过 let 重新声明 js变量</p>
    <h3>变量提升</h3>
    <p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。</p>
    <p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p>
    <p>JavaScript 初始化不会提升</p>
    <table>
        <tr>
            <th>类型</th>
            <th>是否提升</th>
            <th>实例</th>
        </tr>
        <tr>
            <td>通过 var 声明的变量 <br> <em>[ 可先使用再声明 ]</em></td>
            <td>会提升到顶端</td>
            <td>
                <pre>
// 在此处，您可以使用 carName
var carName;
        </pre>
            </td>
        </tr>
        <tr>
            <td>通过 let 定义的变量 <br> <em>[ 需先声明再使用 ]</em></td>
            <td>不会被提升到顶端。
                <ul>
                    <li>在声明 let 变量之前就使用它会导致 ReferenceError</li>
                    <li>变量从块的开头一直处于“暂时死区”，直到声明为止</li>
                </ul>
            </td>
            <td>
                <pre>
// 在此处，您不可以使用 carName
let carName;
        </pre>
            </td>
        </tr>
        <tr>
            <td> const 定义的变量 <br> <em>[ 需先声明再使用 ]</em></td>
            <td>不会提升到顶端</td>
            <td>
                <pre>
carName = "Volvo";    // 在这里不可以使用 carName 变量
const carName = "Volvo";
        </pre>
            </td>
        </tr>
    </table>
    <br>
    <hr>
    <strong>const 关键字</strong>
    <p>const 用于声明一个或多个常量，声明时必须进行初始化，且初始化后值不能重新赋值。</p>
    <h4>const 和 let 的相似点和区别</h4>
    <table>
        <tr>
            <th></th>
            <th>const</th>
            <th>let</th>
        </tr>
        <tr>
            <td>相似点</td>
            <td colspan="2">
                <ul>
                    <li>二者都是块级作用域</li>
                    <li>都不能和它所在作用域内的其他变量或函数拥有相同的名称</li>
                </ul>
        </tr>
        <tr>
            <td>区别</td>
            <td colspan="2">
                <ul>
                    <li>const声明的常量必须初始化，而let声明的变量不用</li>
                    <li>const 定义常量的值不能通过再赋值修改，也不能再次声明。而 let 定义的变量值可以修改。</li>
                </ul>
            </td>
        </tr>
    </table>
    <em>const 特点</em> <br>
    <ul>
        <li>块作用域 - 在块作用域内使用 const 声明的变量与 let 变量相似。无法从快外访问</li>
        <li>在声明时赋值 - JavaScript const 变量必须在声明时赋值</li>
        <li>不是真正的常数 - 没有定义常量值。它定义了对值的常量 <em>引用</em>。因此，我们不能更改常量原始值，但我们可以更改常量对象的属性。
            <ul>
                <li>原始值 ~ 我们将一个原始值赋给常量，我们就不能改变原始值
                    <pre>
const PI = 3.141592653589793;
        PI = 3.14;      // 会出错
        PI = PI + 10;   // 也会出错
                </pre>
                </li>
                <li>常量对象 ~ 可以更改常量对象的属性，但是无法重新为常量对象赋值
                    <pre>
// 您可以创建 const 对象：
        const car = {type:"porsche", model:"911", color:"Black"};

        // 您可以更改属性：
        car.color = "White";

        // 您可以添加属性：
        car.owner = "Bill";
        ————————————————————————————————————————
        // 无法重新为常量对象赋值
        const car = {type:"porsche", model:"911", color:"Black"};
        car = {type:"Volvo", model:"XC60", color:"White"};    // ERROR
                </pre>
                </li>
                <li>常量数组 ~ 可以更改常量数组的元素，但是您无法重新为常量数组赋值
                    <pre>
// 您可以创建常量数组：
    const cars = ["Audi", "BMW", "porsche"];

        // 您可以更改元素：
        cars[0] = "Honda";

        // 您可以添加元素：
        cars.push("Volvo");
        ————————————————————————————————————————
        const cars = ["Audi", "BMW", "porsche"];
        cars = ["Honda", "Toyota", "Volvo"];    // ERROR
                </pre>
                </li>
            </ul>
        </li>
    </ul>
    <h3>重新声明</h3>
    <table>
        <tr>
            <th>位置</th>
            <th>类型</th>
            <th>是否允许重新声明变量</th>
            <th>实例</th>
        </tr>
        <tr>
            <td>任何位置</td>
            <td>使用 var 重新声明 JavaScript变量</td>
            <td>允许</td>
            <td>
                <pre>
var x = 2;    //  合法
var x = 3;    //  合法
x = 4;        //  合法
        </pre>
            </td>
        </tr>
        <tr>
            <td>在同一作用域或块中</td>
            <td>使用已有的 var 或 let 变量重新声明或重新赋值给 const</td>
            <td>不允许</td>
            <td>
                <pre>
var x = 2;         // 允许
const x = 2;       // 不允许
{
  let x = 2;     // 允许
  const x = 2;   // 不允许
}
        </pre>
            </td>
        </tr>
        <tr>
            <td>在同一作用域或块中</td>
            <td>为已有的 const 变量重新声明声明或赋值</td>
            <td>不允许</td>
            <td>
                <pre>
const x = 2;       // 允许
const x = 3;       // 不允许
x = 3;             // 不允许
var x = 3;         // 不允许
let x = 3;         // 不允许

{
  const x = 2;   // 允许
  const x = 3;   // 不允许
  x = 3;         // 不允许
  var x = 3;     // 不允许
  let x = 3;     // 不允许
}
        </pre>
            </td>
        </tr>
        <tr>
            <td>在另外的作用域或块中</td>
            <td>重新声明 const </td>
            <td>允许</td>
            <td>
                <pre>
const x = 2;       // 允许

{
  const x = 3;   // 允许
}

{
  const x = 4;   // 允许
}
        </pre>
            </td>
        </tr>
    </table>
    <em>总结:</em> <br>
    <p>任何位置，允许通过 var 重新声明 js变量</p>
    <p>不同作用域或块中，允许重新声明 const常量</p>
    <em>总结 ： （var let const）</em>
    <p>任何位置，允许通过 var 重新声明 js变量</p>
    <p>不同作用域或块中，允许通过 let 重新声明 js变量</p>
    <p>不同作用域或块中，允许重新声明 const常量</p>

    <hr>

    <p><strong>HTML DOM</strong></p>

    <p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。</p>
    <img src="https://www.runoob.com/images/pic_htmltree.gif" alt="DOM树">

    <p><em>HTML DOM 的作用</em></p>
    <p>通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML</p>
    <ul>
        <li>JavaScript 能够改变页面中的所有 HTML 元素</li>
        <li>JavaScript 能够改变页面中的所有 HTML 属性</li>
        <li>JavaScript 能够改变页面中的所有 CSS 样式</li>
        <li>JavaScript 能够对页面中的所有事件做出反应</li>
    </ul>

    <p><em>查找 HTML 元素</em></p>
    <ul>
        <li>通过 id 找到 HTML 元素 -~- varible = document.getElement<em>ById("id name")</em>;</li>
        <li>通过标签名找到 HTML 元素 -~- varible = document.getElement<em>sByTagName("tag name")</em>;</li>
        <li>通过类名找到 HTML 元素 -~- varible = document.getElement<em>sByClassName("class name")</em>;</li>
    </ul>

    <p><em>改变 HTML</em></p>
    <ul>
        <li>改变 HTML 输出流
            <ul>
                <li>语法 :
                    <pre>document<em>.write()</em></pre>
                </li>
            </ul>
        </li>
        <li>改变 HTML 内容
            <ul>
                <li>语法 :
                    <pre>document.getElementById(id)<em>.innerHTML = 新 HTML</em></pre>
                </li>
            </ul>
        </li>
        <li>改变 HTML 属性
            <ul>
                <li>语法 :
                    <pre>document.getElementById(id)<em>.attribute='新属性值'</em></pre>
                </li>
            </ul>
        </li>
        <li>改变 HTML 样式
            <ul>
                <li>语法 :
                    <pre>document.getElementById(id)<em>.style.property='新样式'</em></pre>
                </li>
            </ul>
        </li>
        <li></li>
    </ul>

    <p><em>对事件做出反应</em></p>
    <p>执行事件的步骤：</p>
    <ul>
        <li>1、获取事件源
            <ul>
                <li>
                    <pre>&lt;button id="btn">唐伯虎&lt;/button></pre>
                </li>
            </ul>
        </li>
        <li>2、注册事件（绑定事件）
            <ul>
                <li>
                    <pre> let btn = document.getElementById('btn');</pre>
                </li>
            </ul>
        </li>
        <li>3、添加事件处理程序（函数赋值）
            <ul>
                <li>
                    <pre>btn.onclick = () => alert('点秋香');</pre>
                </li>
            </ul>
        </li>
    </ul>

    <p><em>HTML DOM EventListener</em></p>
    <em>语法 ：</em>
    <pre>element.addEventListener(event, function, useCapture);</pre>
    <ul>
        <li>第一个参数是事件的类型 (如 "click" 或 "mousedown").</li>
        <li>第二个参数是事件触发后调用的函数。</li>
        <li>第三个参数是个布尔值用于描述事件是冒泡(默认：false)还是捕获（true）。该参数是可选的</li>
    </ul>

    <p><em>向原元素添加事件句柄</em></p>
    <em>语法 ：</em>
    <pre>element.addEventListener("事件", function(){ // 函数代码 }, false/true);</pre>

    <p><em>移除由 addEventListener() 方法添加的事件句柄</em></p>
    <em>语法 ：</em>
    <pre>element.removeEventListener("事件", 函数);</pre>

    <p><em>HTML DOM 元素 (节点)</em></p>
    <p>创建新的 HTML 元素 (节点) - appendChild() - 添加新元素到尾部</p>
    <em>语法 ：</em>
    <pre>
        // 先创建一个元素
        var 子Node名 = document<em>.createElement</em>("<em>tagname</em>");
        var Node内容名 = document<em>.createTextNode</em>("text");
        newNode名<em>.appendChild</em>(Node内容名);

        // 在已存在的父元素中添加它
        var 父Node名 = document.getElementById("<em>id name</em>");
        父Node名<em>.appendChild</em>(子Node名);
    </pre>

    <p>创建新的 HTML 元素 (节点) - appendChild() - 添加新元素到开始位置</p>
    <em>语法 ：</em>
    <pre>
        // 先创建一个元素
        var 子Node名 = document<em>.createElement</em>("<em>tagname</em>");
        var Node内容名 = document<em>.createTextNode</em>("text");
        newNode名<em>.appendChild</em>(Node内容名);

        // 查找 父Node 和 弟Node
        var 父Node名 = document.getElementById("<em>id name</em>");
        var 弟Node名 = document.getElementById("<em>id name</em>");
        父Node名<em>.insertBefore</em>(子Node名, 弟Node名);
    </pre>

    <p>移除已存在的元素 - removeChild()</p>
    <em>语法 ：</em>
    <pre>
        // 查找 父Node 元素
        var 父Node名 = document.getElementById("<em>id name</em>");
        // 查找 被移除 子Node 元素
        var 子Node名 = document.getElementById("<em>i name</em>");
        父Node名<em>.removeChild</em>(子Node名);
    </pre>

    <p>替换 HTML 元素 - replaceChild()</p>
    <em>语法 ：</em>
    <pre>
        // 先创建替代元素
        var 子Node名 = document<em>.createElement</em>("<em>tagname</em>");
        var Node内容名 = document<em>.createTextNode</em>("text");
        newNode名<em>.appendChild</em>(Node内容名);

        // 查找 父Node 元素 和被替换 被替子Node 元素
        var 父Node名 = document.getElementById("<em>id name</em>");
        var 被替子Node名 = document.getElementById("<em>id name</em>");
        父Node名<em>.removeChild</em>(子Node名, 被替子Node名);
    </pre>

    <strong><em>HTML DOM 集合(Collection)</em></strong>
    <hr width="50%">
    <p><em>HTMLCollection 对象</em></p>
    <ul>
        <li>getElementsByTagName() 方法返回 HTMLCollection 对象。</li>
        <li>HTMLCollection 对象类似包含 HTML 元素的一个数组。</li>
        <li>集合中的元素可以通过索引(以 0 为起始位置)来访问。</li>
    </ul>
    <pre>var x = document.getElementsByTagName("p");
    y = x[1]; // 访问第二个 &lt;p> 元素</pre>

    <p><em>HTMLCollection 对象 length 属性</em></p>
    <ul>
        <li>HTMLCollection 对象的 length 属性定义了集合中元素的数量。</li>
        <li>集合 length 属性常用于遍历集合中的元素</li>
        <li>HTMLCollection 不是一个数组！但可以像数组一样，使用索引来获取元素。无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。</li>
    </ul>
    <pre>
        var myCollection = document.getElementsByTagName("p");
        document.getElementById("demo").innerHTML = "文档包含" + myCollection.length + " 个段落。";
        // 输出结果：文档包含3 个段落。</pre>
    <pre>
        var myCollection = document.getElementsByTagName("p");
        var i;
        for (i = 0; i < myCollection.length; i++) {
        myCollection[i].style.backgroundColor = "red";  //修改所有 &lt;p> 元素的背景颜色
    }</pre>

    <hr width="50%">
    <p><em>HTML DOM NodeList 节点列表</em></p>
    <ul>
        <li>所有浏览器的 <em>childNodes</em> 属性返回的是 NodeList 对象，大部分浏览器的 <em>querySelectorAll()</em> 返回 NodeList 对象。</li>
        <li>NodeList 中的元素可以通过索引(以 0 为起始位置)来访问。</li>
    </ul>
    <pre>        var myNodeList = document.querySelectorAll("p");
        y = myNodeList[1]; // 访问第二个 &lt;p> 元素</pre>

    <p><em>NodeList 对象 length 属性</em></p>
    <ul>
        <li>NodeList 对象 length 属性定义了节点列表中元素的数量</li>
        <li>length 属性常用于遍历节点列表。</li>
        <li>NodeList 对象 也类似数组，但不是数组。同 Collection 对象</li>
    </ul>
    <pre>
        var myNodelist = document.querySelectorAll("p"); // 获取 &lt;p> 元素的集合
        document.getElementById("demo").innerHTML = myNodelist.length; // 显示节点列表的元素个数</pre>
    <pre>
        var myNodelist = document.querySelectorAll("p");
        var i;
        for (i = 0; i < myNodelist.length; i++) {
        myNodelist[i].style.backgroundColor = "red";  // 修改节点列表中所有 &lt;p> 元素的背景颜色
    }</pre>

    <p><strong>HTMLCollection 与 NodeList 的区别和相似</strong></p>
    <table>
        <tr>
            <th>类</th>
            <th>所属集合</th>
            <th>获取</th>
            <th>是否包含 属性节点 和 文本节点</th>
            <th>使用索引获取</th>
            <th>length属性</th>
        </tr>
        <tr>
            <td>Collection 对象</td>
            <td>是 HTML 元素的集合</td>
            <td>可以通过 name，id 或索引来获取</td>
            <td>不 包含属性节点和文本节点</td>
            <td rowspan="2">都可以使用索引 (0, 1, 2, 3, 4, ...) 来获取元素</td>
            <td rowspan="2">都有 length 属性</td>
        </tr>
        <tr>
            <td>NodeList 对象</td>
            <td>是一个文档节点的集合</td>
            <td>只能通过索引来获取。</td>
            <td>包含属性节点和文本节点</td>
        </tr>
    </table>

    <p><strong>querySelectorAll()和getElementsByTagName() 的区别</strong></p>
    <p>主要区别就是返回值。</p>
    <ul>
        <li>querySelectorAll() : 返回的是NodeList集合，是一个动态集合</li>
        <li>getElementsByTagName() ：返回的是HTMLCollection集合,是一个静态集合</li>
    </ul>
    <p>动态集合和静态集合的最大区别 ：</p>
    <ul>
        <li>动态集合指的就是元素集合会随着DOM树元素的增加而增加，减少而减少；</li>
        <li>静态集合则不会受DOM树元素变化的影响。</li>
    </ul>

    <hr>
    <p><strong>JavaScript 对象</strong></p>
    <ul>
        <li>JavaScript 中的所有事物都是对象：字符串、数值、数组、函数...</li>
        <li>对象只是带有属性和方法的特殊数据类型。</li>
        <li>JavaScript 允许自定义对象</li>
    </ul>
    <hr width="50%">
    <p>属性是与对象相关的值</p>
    <p><em>访问对象的属性</em></p>
    <p>语法：</p>
    <p><em>objectName.propertyName</em></p>
    <pre>        var message="Hello World!";
        var x=message.length; // 输出结果  12</pre>

    <hr width="50%">
    <p>方法是能够在对象上执行的动作</p>
    <p><em>访问对象的方法</em></p>
    <p>语法：</p>
    <p><em>objectName.methodName()</em></p>
    <pre>        var message="Hello world!";
        var x=message.toUpperCase(); // 输出结果  HELLO WORLD!</pre>

    <hr width="50%">
    <p><em>创建JavaScript 对象</em></p>

    <h3>浏览器对象模型 BOM</h3>
    <p><strong>浏览器对象模型（Browser Object Model (BOM)）允许 JavaScript 与浏览器对话</strong></p>
    <h4>Window 对象</h4>
    <ul>
        <li>所有浏览器都支持 window 对象。它代表浏览器的窗口。</li>
        <li>所有全局 JavaScript 对象，函数和变量自动成为 window 对象的成员。</li>
        <li>全局变量是 window 对象的属性。</li>
        <li>全局函数是 window 对象的方法。</li>
        <li>甚至（HTML DOM 的）document 对象也是 window 对象属性</li>
    </ul>
    <h4>窗口尺寸</h4>
    <p>两个属性可用用于确定浏览器窗口的尺寸:</p>
    <ul>
        <li>window.innerHeight - 浏览器窗口的内高度（以像素计）</li>
        <li>window.innerWidth - 浏览器窗口的内宽度（以像素计）</li>
    </ul>
    <p>一个实用的 JavaScript 解决方案（包括所有浏览器）：</p>
    <pre>
var w = window.innerWidth
|| document.documentElement.clientWidth
|| document.body.clientWidth;

var h = window.innerHeight
|| document.documentElement.clientHeight
|| document.body.clientHeight; </pre>

    <h4>其他 Window 方法</h4>
    <ul>
        <li>window<em>.open()</em> - 打开新窗口</li>
        <li>window<em>.close()</em> - 关闭当前窗口</li>
        <li>window<em>.moveTo()</em> - 移动当前窗口</li>
        <li>window<em>.resizeTo()</em> - 调整当前窗口的尺寸</li>
    </ul>

    <h4>Window Screen</h4>
    <p>window.screen 对象包含用户屏幕的信息。</p>
    <p>window.screen 对象不带 window 前缀也可以写：</p>
    <ul>
        <li>screen<em>.width</em> - 返回以像素计的访问者屏幕宽度。</li>
        <li>screen<em>.height</em> - 返回以像素计的访问者屏幕的高度。</li>
        <li>screen<em>.availWidth</em> - 返回访问者屏幕的宽度，以像素计，减去诸如窗口工具条之类的界面特征。</li>
        <li>Screen<em>.availHeight</em> - 返回访问者屏幕的高度，以像素计，减去诸如窗口工具条之类的界面特征。</li>
        <li>screen<em>.colorDepth</em> - 返回用于显示一种颜色的比特数。</li>
        <li>screen<em>.pixelDepth</em> - 返回屏幕的像素深度</li>
    </ul>
    <pre>对于现代计算机，颜色深度和像素深度是相等的。</pre>

    <h4>Window Location</h4>
    <p>window.location 对象可用于获取当前页面地址（URL）并把浏览器重定向到新页面。</p>
    <p>window.location 对象可不带 window 前缀书写:</p>
    <ul>
        <li>window.location<em>.href</em> - 返回当前页面的 href (URL)</li>
        <li>window.location<em>.hostname</em> - 返回 web 主机的域名</li>
        <li>window.location<em>.pathname</em> - 返回当前页面的路径或文件名</li>
        <li>window.location<em>.protocol</em> - 返回使用的 web 协议（http: 或 https:）</li>
        <li>window.location<em>.port</em> - 返回（当前页面的）互联网主机端口的编号
            <pre>如果端口号是默认值（对于 http 为 80，对于 https 为 443），则大多数浏览器将显示 0 或不显示。</pre>
        </li>
        <li>window.location<em>.assign</em> - 加载新文档</li>
    </ul>

    <h4>Window History</h4>
    <p>window.history 对象包含浏览器历史。</p>
    <p>为了保护用户的隐私，JavaScript 访问此对象存在限制。</p>
    <p>window.history 对象可不带 window 书写，一些方法:</p>
    <ul>
        <li>history<em>.back()</em> - 等同于在浏览器点击后退按钮</li>
        <li>history<em>.forward()</em> - 等同于在浏览器中点击前进按钮</li>
    </ul>

    <h4>Window Navigator</h4>
    <p>window.navigator 对象包含有关访问者的信息。</p>
    <p>window.navigator 对象可以不带 window 前缀来写:</p>
    <ul>
        <li>navigator<em>.appName - 返回浏览器的应用程序名称</em></li>
        <pre>"Netscape" 是 IE11、Chrome、Firefox 以及 Safari 的应用程序名称的统称</pre>
        <li>navigator<em>.appCodeName - 返回浏览器的应用程序代码名称</em></li>
        <pre>不要依赖它！"Mozilla" 是 Chrome、Firefox、IE、Safari 以及 Opera 的应用程序代码名称。</pre>
        <li>navigator<em>.appVersion</em> - 返回有关浏览器的版本信息</li>
        <li>navigator<em>.product</em> - 返回浏览器引擎的产品名称</li>
        <pre>不要依赖它！大多数浏览器都将 “Gecko” 作为产品名称返回！</pre>
        <li>navigator<em>.userAgent</em> - 返回由浏览器发送到服务器的用户代理报头（user-agent header）</li>
        <li>navigato<em>r.platform - 返回浏览器平台（操作系统）</em></li>
        <li>navigator<em>.language</em> - 返回浏览器语言</li>
        <li>navigator<em>.onLine</em> - 浏览器是否在线？假如浏览器在线，返回 true</li>
        <li>navigator<em>.javaEnabled()</em> - Java 是否启用？如果 Java 已启用,返回 true</li>
        <li>navigator<em>.cookieEnabled</em> - 如果 cookie 已启用，返回 true，否则返回 false</li>
    </ul>
    <p><strong>警告</strong></p>
    <p>来自 navigator 对象的信息通常是误导性的，不应该用于检测浏览器版本，因为：</p>
    <ul>
        <li>不同浏览器能够使用相同名称</li>
        <li>导航数据可被浏览器拥有者更改</li>
        <li>某些浏览器会错误标识自身以绕过站点测试</li>
        <li>浏览器无法报告发布晚于浏览器的新操作系统</li>
    </ul>

    <h4>JavaScript 弹出框</h4>
    <p>JavaScript 有三种类型的弹出框：</p>
    <ul>
        <li>警告框 - 如果要确保信息传递给用户，通常会使用警告框。当警告框弹出时，用户将需要单击“确定”来继续。
            <pre>window.alert() 方法可以不带 window 前缀来写。<br> 
            <em>alert("sometext");</em> </pre>
        </li>
        <li>确认框 - 如果希望用户验证或接受某个东西，则通常使用“确认”框。当确认框弹出时，用户将不得不单击“确定”或“取消”来继续进行。
            <pre>window.confirm() 方法可以不带 window 前缀来编写 <br>
            <em>window.confirm("sometext");</em> <br>
            如果用户单击“确定”，该框返回 true。如果用户单击“取消”，该框返回 false。</pre>
        </li>
        <li>提示框 - 如果希望用户在进入页面前输入值，通常会使用提示框。当提示框弹出时，用户将不得不输入值后单击“确定”或点击“取消”来继续进行。
            <pre>window.prompt() 方法可以不带 window 前缀来编写。 <br>
            <em>prompt("sometext","defaultText");</em> <br>
            如果用户单击“确定”，该框返回输入值。如果用户单击“取消”，该框返回 NULL。</pre>
        </li>
    </ul>
    <p>
        <pre>折行 - 如需在弹出框中显示折行，请在反斜杠后面加一个字符 n。</pre>
    </p>

    <h4>Timing 事件</h4>
    <p>定时事件（ Timing Events） : JavaScript 可以在时间间隔内执行。</p>
    <p>通过 JavaScript 使用的有两个关键的方法：</p>
    <ul>
        <li><em>setTimeout(function, milliseconds)</em> - 在等待指定的毫秒数后执行函数。</li>
        <li><em>setInterval(function, milliseconds)</em> - 持续重复执行函数。</li>
    </ul>

    <p><strong>setTimeout() 方法</strong></p>
    <p><em>停止执行</em> setTimeout() 方法 - <em>clearTimeout() 方法</em> 停止执行 setTimeout() 中规定的函数</p>
    <p>语法：</p>
    <pre>clearTimeout(timeoutVariable) <br>使用从 setTimeout() 返回的变量</pre>
    <p>实例：</p>
    <pre>        &lt;button onclick="myVar = setTimeout(myFunction, 3000)">试一试&lt;/button>
        &lt;button onclick="clearTimeout(myVar)">停止执行&lt;/button></pre>

    <p><strong>setInterval() 方法</strong></p>
    <p><em>停止执行</em> setInterval() 方法 - <em>clearInterval() 方法</em> 停止执行 setInterval() 中指定的函数</p>
    <p>语法：</p>
    <pre>clearInterval() 方法 <br>使用从 setInterval() 返回的变量</pre>
    <p>实例：</p>
    <pre>&lt;button onclick="clearInterval(myVar)">停止时间&lt;/button></pre>
    <p>js实例 - 【显示当前时间】</p>
    <p id="demo"></p>
    <script>
        setInterval(displayTime, 1000)

        function displayTime() {
            var myD = new Date;
            document.getElementById('demo').innerHTML = myD.toLocaleString();
        }
    </script>
    <pre>
    &lt;p id="demo">&lt;/p>
    &lt;script>
        setInterval(displayTime, 1000)
        function displayTime () {
            var myD = new Date;
            document.getElementById('demo').innerHTML = myD.toLocaleString();
        }
    &lt;/script>
    </pre>

    <h4>Cookies</h4>
    <p>Cookie 让您在网页中存储用户信息</p>
    <p><strong>什么是 cookie</strong></p>
    <ul>
        <li>Cookie 是在您的计算机上存储在小的文本文件中的数据。</li>
        <li>当 web 服务器向浏览器发送网页后，连接被关闭，服务器会忘记用户的一切。</li>
        <li>Cookie 是为了解决“如何记住用户信息”而发明的：
            <ul><li>当用户访问网页时，他的名字可以存储在 cookie 中。</li>
                <li>下次用户访问该页面时，cookie 会“记住”他的名字。</li></ul>
        </li>
        <li>Cookie 保存在名称值对中,比如： username = Bill Gates</li>
        <li>当浏览器从服务器请求一个网页时，将属于该页的 cookie 添加到该请求中。这样服务器就获得了必要的数据来“记住”用户的信息。</li>
    </ul>

    <p>JavaScript 可以用 document.cookie 属性创建、读取、删除 cookie。</p>
    <p><strong>创建 cookie</strong></p>
    <pre>
        document.cookie = "username=Bill Gates";
        // 添加有效日期（UTC 时间）。默认情况下，在浏览器关闭时会删除 cookie
        document.cookie = "username=John Doe; expires=Sun, 31 Dec 2017 12:00:00 UTC";
        // 通过 path 参数，您可以告诉浏览器 cookie 属于什么路径。默认情况下，cookie 属于当前页。
        document.cookie = "username=Bill Gates; expires=Sun, 31 Dec 2017 12:00:00 UTC; path=/";</pre>
    <p><strong>读取 cookie</strong></p>
    <pre>
        var x = document.cookie;
        // document.cookie 会在一条字符串中返回所有 cookie</pre>
    <p><strong>改变 cookie</strong></p>
    <pre>
        document.cookie = "username=Steve Jobs; expires=Sun, 31 Dec 2017 12:00:00 UTC; path=/";
        // 旧 cookie 被覆盖。</pre>
    <p><strong>删除 cookie</strong></p>
    <pre>
        document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
        // 直接把 expires 参数设置为过去的日期即可
        // 应该定义 cookie 路径以确保删除正确的 cookie。不指定路径，一些浏览器不会让你删除 cookie。</pre>

    <p><strong>Cookie 字符串</strong></p>
    <ul>
        <li>document.cookie 属性看起来像一个正常的文本字符串。但它不是</li>
        <li>即使你向 document.cookie 写一份完整的 cookie 字符串，当再次读取时，你只能看到它的名称-值对。</li>
        <li>如果设置了新 cookie，则旧的 cookie 不会被覆盖。</li>
        <li>想找到一个指定 cookie 的值，你必须编写 JavaScript 函数来搜索 cookie 字符串中的 cookie 值。</li>
    </ul>
    <h5>设置 cookie 的函数</h5>
    <h5>获取 cookie 的函数</h5>
    <h5>检测 cookie 的函数</h5>
</body>

</html>