## vue

参考

- [key的作用](https://www.bilibili.com/video/BV1m7411P7oD?spm_id_from=333.1007.top_right_bar_window_history.content.click)

### 1 - vue 中的 key 的作用

- key的作用主要是为了高效地更新虚拟dom，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少dom操作量，提高性能。
- 使用 key 时，vue 会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。
- 不使用 key，vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法，但这种默认的性能优化策略，会导致更新时出错

***

### 2 - Vue 中组件之间的通信方式（多种）

vue 中，组件之间的关系分为 3 种

- 父子关系
- 兄弟关系
- 后代关系

#### 适用于父子组件通信的方式

- props / $emit
- ref 与 $parent / $children
    - `ref`：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例
    - `$parent / $children`：访问父 / 子实例

#### 适用于后代组件通性的方式

- provide / inject

- $attrs/$listeners

#### 适用于父子、兄弟、后代组件通信

- EventBus （$emit / $on）
- Vuex 状态管理模式

***

### 3- computed 和 watch 有什么区别?

- computed
    -  支持缓存，只有依赖数据发生改变，才会重新进行计算，不支持异步
- watch
    - 不支持缓存，数据变化，直接会触发相应的操作，支持异步

***

### 4 - Vue 子组件怎样直接调用父组件方法 

this.$parent

***

### 5 - Vue 父组件怎样直接调用子组件方法

this.$children

***

### 6 - 组件中 data 为什么是一个函数

- 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，
- 如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响

***

### 7 - v-model是什么的语法糖

原生input

#### 使用自定义事件的表单输入组件

自定义事件也可用来创建自定义的表单输入组件，使用 `v-model` 来进行数据双向绑定

```html
<input v-model="something">
```

仅仅时一个语法糖：

```html
<input v-bind:value="something" v-on:input="something = $event.target.value">
```

所以在组件中使用时，相当于下面的简写

```html
<custom-input v-bind:value="something" v-on:input = "something = arguments[0]"></custom-input>
```



***

### 8 - 事件修饰符

常见的 6 个修饰符：

| 事件修饰符 |                         说明                         |
| :--------: | :--------------------------------------------------: |
|  .prevent  |   阻止默认行为（如：阻止 a 链接的跳转、表单提交）    |
|   .stop    |                     阻止事件冒泡                     |
|  .capture  |           以捕获模式触发当前的事件处理函数           |
|   .once    |                 绑定的事件只触发一次                 |
|   .self    | 只有在 event.target 是当前元素自身时触发事件处理函数 |
|  .passive  |             对DOM的默认事件进行性能优化              |

***

### 9 - Vue是如何实现双向绑定的 

- vue 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的， 也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变
- 核心：关于VUE双向数据绑定，其核心是 Object.defineProperty( )方法

***

### 10 - 无法被监听到数据变化的几种情况

- 通过数组索引改变数组元素的值；
- 改变数组的长度

- 对象的增加、删除、修改无法被vue监听到

***

### 11 - 生命周期详解，做了哪些事

| 生命周期函数  |           执行时机           | 所属阶段 | 执行次数  |       应用场景       |
| :-----------: | :--------------------------: | :------: | :-------: | :------------------: |
| beforeCreate  |     在内存中创建组件之前     | 创建阶段 | 唯一 1 次 |                      |
|    created    |    组件在内存中创建完毕后    | 创建阶段 | 唯一 1 次 | 发 ajax 请求初始数据 |
|  beforeMount  |   在粗剪初次渲染到页面之前   | 创建阶段 | 唯一 1 次 |                      |
|    mounted    |  组件初次在页面中渲染完毕后  | 创建阶段 | 唯一 1 次 |    操作 DOM 元素     |
| beforeUpdate  |     在组件被重新渲染之前     | 运行阶段 | 0 或 多次 |                      |
|    updated    | 组件在页面中被重新渲染完毕后 | 运行阶段 | 0 或 多次 |                      |
| beforeUnmount |       在组件被销毁之前       | 销毁阶段 | 唯一 1 次 |                      |
|   unmounted   |  组件被销毁后（页面和内存）  | 销毁阶段 | 唯一 1 次 |                      |

***

### 12 - 异步更新队列

Vue在观察数据变化时并不是直接更新DOM,而是开启一个队列，然后缓冲在同一个时间下发生的所有的数据改变，同时去重，只有在下一个事件循环中，VUE才会刷新队列，执行新的内容。$neckTick执行时就是DOM更新完成后所以我们对数据变化的DOM对象做处理时，应该在$nextTick函数中做处理。

***

## typescript

### 13 - 数据类型（Nerver 类型，unknown 类型）

|  类型   |        例子        |               描述               |
| :-----: | :----------------: | :------------------------------: |
| number  |    1, -33, 2.5     |             任意数字             |
| string  |      “hello”       |            任意字符串            |
| boolean |    true、false     |       布尔值 true 或 false       |
| 字面量  |       其本身       |   限制变量的值就是该字面量的值   |
|   any   |         *          |             任意类型             |
| unknow  |         *          |          类型安全的 any          |
|  void   | 空值（undefined）  |       没有值（或undefined)       |
|  never  |       没有值       |           不能是任何值           |
| object  | ｛name: ‘孙悟空’｝ |          任意的 JS 对象          |
|  array  |     [1, 2, 3]      |          任意的 JS 数组          |
|  tuple  |       [4, 5]       | 元组， TS新增类型， 固定长度数组 |
|  enum   |     enum{A, B}     |        枚举， TS新增类型         |

### 14 - 交叉类型联合类型 

- 交叉类型
    - 可以通过 & 将变量设置多种类型的交集
- 联合类型
    - 可以通过管道(|)将变量设置多种类型，赋值时只能根据设置的类型来赋值

### 15 - 声明文件的作用 

- 在[typescript](https://so.csdn.net/so/search?q=typescript&spm=1001.2101.3001.7020)中存在两种文件后缀名，一种是 `.ts`,另一种是`.d.ts`结尾的文件，我们主要的代码都是写在以`.ts`文件结尾的文件中。而`.d.ts`结尾的文件就是声明文件
- TypeScript 作为 JavaScript 的超集，通过直接引用可以调用库的类和方法，但是却无法使用TypeScript 诸如类型检查等特性功能。为了解决这个问题，需要将这些库里的函数和方法体去掉后只保留导出类型声明，而产生了一个描述 JavaScript 库和模块信息的声明文件。通过引用这个声明文件，就可以借用 TypeScript 的各种特性来使用库文件了。

### 16 - 类的访问修饰符

|     访问修饰符     |                说明                |
| :----------------: | :--------------------------------: |
| **public（默认）** |    公有，可以在任何地方被访问。    |
|   **protected**    | 受保护，可以被其自身以及其子类访问 |
|    **private**     |   私有，只能被其定义所在的类访问   |

### 17 - type和 interface 的区别 

type 可以而 interface 不行

- type 可以声明基本类型别名，联合类型，元组等类型
- type 语句中还可以使用 typeof 获取实例的 类型进行赋值

interface 可以而 type 不行

- interface 能够声明合并

***

## es6

### 18 - Promise,async/await理解

- new Promise的时候里面内容会立即执行！！因而为了能实现调用时执行，Promise一般都是作为函数的返回值，可以将普通的回调函数作为参数的形式改造成promise的形式，和执行如果setTimeout的效果是一样的。promise返回的是reject，就会抛异常，一般reject的通过catch来捕获异常

- async函数（异步函数）
    - 函数的返回值为promise对象
    - promise对象的结果由aync函数的返回值决定。

- await表达式
    - await操作符用于等待一个Promise对象。他只能在async function中使用
    - await得到的结果就是Promise成功的value

### 19 - 箭头函数及 this 指向 

- 箭头函数提供了一种更加简洁的函数书写方式，箭头函数多用于匿名函数的定义
- 箭头函数 this 指向函数声明时所在作用域下 this 的值 (this 是静态的)

## 其他

### 20 - 介绍一下 webpack 

 webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency
graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle

### 21 - Npm作用?用法

npm是 Node.js 默认的、以 JavaScript 编写的软件包管理系统

### 22 - Git作用?用法

 Git是为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件,它是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目



(1)创建代码仓库 git init

(2)加入所有目录到仓库 git add .

(3)提交 git commit -m "first commit" 简写 git ci

(4)查看git提交状态 git status 简写 git st

(5)借助diff查看具体修改的地方 git diff 修改的文件路径 -号表示删除的部分 +表示添加的部分

(6)撤销未提交的文件 git checkout 文件路径 简写 git co

如果文件已经add，checkout无法撤销，先取消添加

git reset HEAD 文件路径，然后再checkout就ok

(7)查看记录 git log

记录太多，如果想只查看一条，通过id来查看

git log 记录id -1 -p （-1表示只查看一条，-p表示查看具体修改了什么内容）

(8)分支操作git branch

### 23 - Nodejs概述

Node.js 就是运行在服务端的 JavaScript。它是一个基于Chrome JavaScript 运行时建立的一个平台。是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好

